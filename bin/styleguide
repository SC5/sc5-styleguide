#!/usr/bin/env node

var path = require('path'),
  styleguide = require(path.resolve(__dirname, '../lib/styleguide.js')),
  gulp = require('gulp'),
  runSequence = require('run-sequence'),
  chalk = require('chalk'),
  yargs = require('yargs'),
  neat = require('node-neat'),
  extend = require('node.extend'),
  fs = require('fs'),
  argv,
  config,
  configPath,
  sourceFiles = [],
  watchFiles,
  outputPath,
  options;

argv = yargs
  .usage('This is how ' + chalk.cyan.bold('YOU') + ' can generate ' +
    chalk.cyan.bold('COOL') + ' styleguides')
  .example('$0 -s <src> -o <dest>', 'Generate a styleguide to dest using src')
  .example('$0 -s <src> -o <dest> --watch', 'Generate a styleguide to dest using src and run server watching changes')
  .demand('source', chalk.red('Please provide source path using -s <path>'))
  .demand('output', chalk.red('Please provide output path using -o <path>'))
  .alias('o', 'output')
  .alias('s', 'source')
  .alias('c', 'config')
  .describe('s', 'Source file(s)')
  .describe('o', 'Output directory')
  .describe('c', 'Path to config JSON file')
  .describe('server', 'Start minimal web-server to host the styleguide from the output directory')
  .describe('watch', 'Automatically generate styleguide on file change')
  .argv;

if (argv.source.forEach) {
  argv.source.forEach(addSourcePath);
} else {
  addSourcePath(argv.source);
}

function addSourcePath(srcPath) {
  try {
    var p = path.resolve(srcPath);
    if (fs.lstatSync(p).isDirectory()) {
      sourceFiles.push(path.join(p, '**/*.css'));
      sourceFiles.push(path.join(p, '**/*.scss'));
      sourceFiles.push(path.join(p, '**/*.less'));
    } else {
      sourceFiles.push(p);
    }
  } catch (e) {
    sourceFiles.push(srcPath);
  }
}

watchFiles = sourceFiles.slice(0);

outputPath = path.resolve(argv.output);
configPath = argv.config ? path.resolve(argv.config) : undefined;
config = configPath ? require(configPath) : {};

// Resolve overviewPath and styleVariables files in relation to config file location
if (config.overviewPath) {
  config.overviewPath = path.resolve(path.dirname(argv.config), config.overviewPath);
  watchFiles.push(config.overviewPath);
}
if (config.styleVariables) {
  config.styleVariables = path.resolve(path.dirname(argv.config), config.styleVariables);
  watchFiles.push(config.styleVariables);
} else if (config.sassVariables) {
  // For backward compatibility
  config.sassVariables = path.resolve(path.dirname(argv.config), config.sassVariables);
  watchFiles.push(config.sassVariables);
}
options = extend({
  sass: {
    includePaths: neat.includePaths
  },
  server: !!argv.server,
  port: argv.port,
  rootPath: outputPath
}, config);

gulp.task('styleguide', function() {
  return gulp.src(sourceFiles)
    .pipe(styleguide(options))
    .pipe(gulp.dest(outputPath));
});

gulp.task('watch', function() {
  return gulp.watch(watchFiles, ['styleguide']);
});

var tasks = ['styleguide'];
if (argv.watch) {
  tasks.push('watch');
}
runSequence.apply(this, tasks);
